归并排序（Merge Sort）是一种基于分治法的排序算法。其基本思想是将一个数组分成两个子数组，分别对它们进行排序，然后将已排序的子数组合并，最终得到一个有序的数组。
归并排序的时间复杂度为 O(n log n)，是一种稳定的排序算法。

归并排序的步骤：
分割：将数组从中间分为两个子数组，递归地对每个子数组进行归并排序。
合并：将两个已经排序的子数组合并成一个有序的数组。
具体算法过程：
递归地将数组分成两半，直到每个子数组只有一个元素（一个元素的数组被认为是有序的）。
然后从最小的子数组开始，将两个有序的子数组合并成一个较大的有序数组。
重复这个过程，直到所有子数组合并成一个完整的有序数组。
伪代码：
MergeSort(arr):
    if arr has only one element:
        return arr
    else:
        split arr into two halves: left and right
        left = MergeSort(left)
        right = MergeSort(right)
        return Merge(left, right)

Merge(left, right):
    create an empty result array
    while both left and right are non-empty:
        if left[0] <= right[0]:
            append left[0] to result
            remove left[0] from left
        else:
            append right[0] to result
            remove right[0] from right
    append any remaining elements from left or right to result
    return result
归并排序使用的是 分治法，即首先将数组递归地分成更小的子数组，然后再逐步将它们合并。具体的顺序由递归调用的“深度优先”性质决定，即总是先处理左半部分，直到无法再拆分后才开始合并。

以数组 [38, 27, 43, 3, 9, 82, 10] 为例：
划分阶段（自顶向下）：

第一次划分：[38, 27, 43, 3, 9, 82, 10] 被分为两部分：[38, 27, 43] 和 [3, 9, 82, 10]。
对 38, 27, 43 继续划分为：[38] 和 [27, 43]。
再对 [27, 43] 划分为：[27] 和 [43]。
此时，左半部分 [38, 27, 43] 已经完全分解成 [38]、[27] 和 [43]，每个子数组长度为 1，因此它们已经是“有序的”。

合并阶段（自底向上）：

先合并 [27] 和 [43]。因为 27 <= 43，所以 27 放在前面，合并结果为 [27, 43]。
然后合并 [38] 和 [27, 43]。在这个过程中，先比较 38 和 27，因为 27 < 38，所以 27 被放入结果数组。接着比较 38 和 43，因为 38 < 43，所以 38 被放入结果数组，最后将剩下的 43 加入。
最终结果是 [27, 38, 43]。

递归的关键点：
递归的过程是先把数组拆分到最小，然后再从最底层开始合并。因此当你看到 27 和 43 先进行比较时，是因为在划分的过程中，[38] 被单独分离出来，剩下的 [27, 43] 先被处理。
图解递归过程：
                [38, 27, 43, 3, 9, 82, 10]
                      /              \
        [38, 27, 43]                  [3, 9, 82, 10]
         /        \                     /          \
    [38]       [27, 43]           [3, 9]        [82, 10]
                  /   \             /   \          /    \
               [27]  [43]        [3]   [9]     [82]   [10]

# 合并阶段：
1. 合并 [27] 和 [43] -> [27, 43]
2. 合并 [38] 和 [27, 43] -> [27, 38, 43]
3. 合并 [3] 和 [9] -> [3, 9]
4. 合并 [82] 和 [10] -> [10, 82]
5. 合并 [3, 9] 和 [10, 82] -> [3, 9, 10, 82]
6. 最后合并 [27, 38, 43] 和 [3, 9, 10, 82] -> [3, 9, 10, 27, 38, 43, 82]
在这个过程中，27 和 43 被单独分离并合并，所以它们最先被比较和处理。

总结：
递归是从左到右、从上到下拆分，直到数组不能再分。
合并阶段是从底层开始，即从最小的子数组（如 [27] 和 [43]）开始合并，逐步合并到整个数组。
归并过程的详细解释：
我们来看一下归并排序的合并阶段，从最底层到高层的过程：

最底层合并：

假设我们有两个单元素数组 [27] 和 [43]。合并这两个数组时，我们将比较 27 和 43。因为 27 比 43 小，所以 27 被放在结果数组的前面，接着将 43 添加到结果数组中。结果是 [27, 43]。
合并上层：

接下来，我们合并上层的数组，即 [38] 和 [27, 43]。在这一阶段，我们要将 [38] 和 [27, 43] 合并成一个有序的数组。

这个过程是这样进行的：

比较 38 和 27。因为 27 小于 38，所以 27 被放在结果数组中。
接着，27 已经被处理完，结果数组现在是 [27]。我们继续比较 38 和 43。因为 38 小于 43，所以 38 被放在结果数组中。
38 已经被处理完，结果数组现在是 [27, 38]。此时，43 是 27 和 38 的剩余元素，它被直接添加到结果数组中。
合并的结果是 [27, 38, 43]
